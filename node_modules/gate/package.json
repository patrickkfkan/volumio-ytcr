{
  "_args": [
    [
      "gate@^0.3.0",
      "/home/patrickkfkan/dev/volumio/ytcr/node_modules/peer-dial"
    ]
  ],
  "_from": "gate@>=0.3.0 <0.4.0",
  "_id": "gate@0.3.0",
  "_inCache": true,
  "_installable": true,
  "_location": "/gate",
  "_phantomChildren": {},
  "_requested": {
    "name": "gate",
    "raw": "gate@^0.3.0",
    "rawSpec": "^0.3.0",
    "scope": null,
    "spec": ">=0.3.0 <0.4.0",
    "type": "range"
  },
  "_requiredBy": [
    "/peer-dial"
  ],
  "_resolved": "https://registry.npmjs.org/gate/-/gate-0.3.0.tgz",
  "_shasum": "9b2a5eef574dbcced106259012063b8f9cdd3093",
  "_shrinkwrap": null,
  "_spec": "gate@^0.3.0",
  "_where": "/home/patrickkfkan/dev/volumio/ytcr/node_modules/peer-dial",
  "author": {
    "email": "toshihiro.nakamura@gmail.com",
    "name": "Toshihiro Nakamura"
  },
  "bugs": {
    "url": "https://github.com/nakamura-to/gate/issues"
  },
  "contributors": [],
  "dependencies": {},
  "description": "An utility to await multiple asynchronous calls in Node environment",
  "devDependencies": {
    "mocha": "~0.11.0"
  },
  "directories": {},
  "dist": {
    "shasum": "9b2a5eef574dbcced106259012063b8f9cdd3093",
    "tarball": "https://registry.npmjs.org/gate/-/gate-0.3.0.tgz"
  },
  "homepage": "https://github.com/nakamura-to/gate#readme",
  "keywords": [
    "async",
    "await",
    "control-flow",
    "wait"
  ],
  "main": "./lib/gate.js",
  "maintainers": [
    {
      "name": "nakamura-to",
      "email": "toshihiro.nakamura@gmail.com"
    }
  ],
  "name": "gate",
  "optionalDependencies": {},
  "readme": "Gate â€” An utility to await multiple asynchronous calls\n=======================================================\n\nGate is an utility to await multiple asynchronous calls in Node environment.\n\n## Installing\n\n```\n$ npm install gate\n```\n\n## Example\n\nYou can get each asynchronous result by index or name.\n\n### By Index\n\n```js\nvar gate = require('gate');\nvar fs = require('fs');\n\nvar g = gate.create();\nfs.readFile('file1', 'utf8', g.latch({data: 1}));\nfs.readFile('file2', 'utf8', g.latch({data: 1}));\n\ng.await(function (err, results) {\n  if (err) throw err;\n  console.log(results[0].data); // content for file1\n  console.log(results[1].data); // content for file2\n});\n```\n\n### By Name\n\n```js\nvar gate = require('gate');\nvar fs = require('fs');\n\nvar g = gate.create();\nfs.readFile('file1', 'utf8', g.latch('file1Result', {data: 1}));\nfs.readFile('file2', 'utf8', g.latch('file2Result', {data: 1}));\n\ng.await(function (err, results) {\n  if (err) throw err;\n  console.log(results.file1Result.data); // content for file1\n  console.log(results.file2Result.data); // content for file2\n});\n```\n\n## Additions to Error objects\n\nA extra field is added to an Error object.\n\n* `error.gate_locatioin`: The asynchronous call location that the error occurred.\n\n\n## API\n\n`gate` module provides following API. \n\n#### create([Object options]) -> Gate\n\nReturns a Gate object. \n\n* `options`: Optional. The `options` can have followng keys.\n\n<table>\n<tr>\n<th>KEY</th><th>TYPE</th><th>DEFAULT VALUE</th><th>DESCRIPTION</th>\n</tr>\n<tr>\n<td>count</td>\n<td>Number</td>\n<td>-1</td>\n<td>\nA number of times the returned function must be called before an awaiting callback can start.\nNegative value means that count is not specified.\n</td>\n</tr>\n<tr>\n<td>failFast</td>\n<td>Boolean</td>\n<td>true</td>\n<td>\nIndicates whether an awaiting callback is invoked as soon as possible when any error is found. \nIf failFast is true, the found error is set as first argument of the awaiting callback.\n</td>\n</tr>\n</table>\n\n\n```js\nvar g = gate.create();\n```\n\n```js\nvar g = gate.create({count: 5, failFast: false}});\n```\n\n--\n\n`Gate` objects provide following API.\n\n#### latch([String name][, Object mapping]) -> Function\n\nReturns a callback. The callback arguments are mapped with a `mapping` definition.\nIf a count is given to `gate.create()`, the count is decremented.\n\n* `name`: Optional. A name for callback arguments.\nIf not specified, an index number is used as name.\n\n```js\nvar g = gate.create();\nfs.readFile('file1', 'utf8', g.latch('file1Result', {data: 1})); // name is specified\nfs.readFile('file2', 'utf8', g.latch({data: 1}));                // name is not specified\n\ng.await(function (err, results) {\n  if (err) throw err;\n  console.log(results.file1Result.data); // get by name\n  console.log(results[1].data);          // get by index\n});\n\n```\n\n* `mapping`: Optional. An argument mapping definition. The `mapping` gives names to callback arguments. \nThe `mappipng` must be a number or an object.\n * If the `mapping` is a number, single argument is mapped.\n * If the `mapping` is an object, multiple arguments can be mapped.\n * If the `mapping` is `null` or `undefined`, all arguments are mapped as Array.\n\n```js\nvar g = gate.create();\nfs.readFile('file1', 'utf8', g.latch(1));                        // single argument\nfs.readFile('file2', 'utf8', g.latch({data: 1, name: 'file2'})); // multiple arguments\nfs.readFile('file3', 'utf8', g.latch());                         // all arguments\n\ng.await(function (err, results) {\n  if (err) throw err;\n  console.log(results[0]);      // content for file1\n  console.log(results[1].data); // content for file2\n  console.log(results[1].name); // arbitrary value for file2\n  console.log(results[2][0]);   // read error for file3 (1st argument of fs.readFile callback)\n  console.log(results[2][1]);   // content for file3    (2nd argument of fs.readFile callback)\n});\n\n```\n\n#### val(Object value) -> Object\n\nIndicates that a value is a plain value and it's not a mapping index.\n\n* `value`: Required. A plain value.\n\n```js\nvar g = gate.create();\n\n// a number for a `data` property is a mapping index, but a number for `g.val()` is a plain value \nfs.readFile('file1', 'utf8', g.latch({data: 1, i: g.val(1)}));\nfs.readFile('file2', 'utf8', g.latch({data: 1, i: g.val(2)}));\n\ng.await(function (err, results) {\n  if (err) throw err;\n  console.log(results[0].data); // content for file1\n  console.log(results[0].i);    // 1\n  console.log(results[1].data); // content for file2\n  console.log(results[1].i);    // 2\n});\n```\n\n#### await(Function callback(err, results, gate)) -> Function\n\nAwaits all asynchronous calls completion and then runs a `callback`.\n\n* `callback`: Required. A callback to run after all asynchronous calls are done.\n* `err`: An error to indicate any asynhronous calls are failed.\n* `results`: An array to contain each asynchronous result as element.\n* `gate`: A new gate object.\n\n```js\nvar g = gate.create();\nfs.readFile('file1', 'utf8', g.latch({data: 1}));\nfs.readFile('file2', 'utf8', g.latch({data: 1}));\n\ng.await(function (err, results) {\n  if (err) {\n    console.log(err);\n  } else {\n    console.log(results[0].data); \n    console.log(results[1].data); \n  }\n});\n```\n\n### count: Number\n\nGets a current count, if a count is given to `gate.latch()`.\nOtherwise, `-1` is returned.\nThis is a readonly property.\n\n```js\nvar g = gate.create(2);\n\nconsole.log(g.count); // 2\nfs.readFile('file1', 'utf8', g.latch({data: 1}));\nconsole.log(g.count); // 1\nfs.readFile('file2', 'utf8', g.latch({data: 1}));\nconsole.log(g.count); // 0\n```\n\n\n## More Examples\n\n### Arguments Mapping\n\nPass an argument index or an object includes argument indexs to a function being returned from `gate.latch()`. \nIn the object, values except whose type is `number` are recognized arguments. \nTo pass an number as argument, wrap it with `val` function. \n\n```js\nvar gate = require('gate');\nvar fs = require('fs');\nvar exec = require('child_process').exec;\n\nvar g = gate.create();\n\n// single mapping: arguments[1] in the callback will be result\nfs.readFile('file1', 'utf8', latch(1)); \n\n// multiple mapping: arguments[1] and argments[2] in the callback will be result\nexec('cat *.js bad_file | wc -l', g.latch({stdout: 1, stderr: 2}));\n\n// all mapping: arguments will be result\nfs.readFile('file2', 'utf8', g.latch());\n\ng.await(function (err, results) {\n  if (err !== null) {\n    console.log('exec error: ' + err);\n  }\n  console.log('file1: ' + results[0]);\n  console.log('stdout: ' + results[1].stdout);\n  console.log('stderr: ' + results[1].stderr);\n  console.log('file2: ' + results[2]);\n});\n```\n\n### Countdown\n\nPass a count number to `gate.create()` to wait until a set of callbacks are done.\n\n```js\nvar gate = require('gate');\nvar fs = require('fs');\n\nvar files = ['file1', 'file2'];\nvar g = gate.create(files.length);\ng.await(function (err, results) {\n  if (err) throw err;\n  console.log(results[0]);\n  console.log(results[1]);\n});\n\nprocess.nextTick(function () {\n  files.forEach(function (file) {\n    fs.readFile(file, 'utf8', g.latch({name: file, data: 1}));\n  });\n});\n```\n\n### Error Handling\n\nCheck the first argument of the awaiting callback.\nIf the argument is not null, it is any error object.\n\n```js\nvar gate = require('gate');\nvar fs = require('fs');\n\nvar g = gate.create();\nfs.readFile('file1', 'utf8', g.latch({name: 'file1', data: 1}));\nfs.readFile('non-existent', 'utf8', g.latch({name: 'non-existent', data: 1}));\n\ng.await(function (err, results) {\n  // handle any error\n  if (err) {\n    console.log(err);\n  } else {\n    console.log(results);\n  }\n});\n```\n\n### Error Handling - handling all errors\n\nTurn off `failFaslt` option and include an error object in each result. \nThen you can handle all errors by yourself.\n\n```js\nvar gate = require('gate');\nvar fs = require('fs');\n\nvar g = gate.create({failFast: false});\nfs.readFile('non-existent1', 'utf8', g.latch({err: 0, data: 1}));\nfs.readFile('non-existent2', 'utf8', g.latch({err: 0, data: 1}));\n\ng.await(function (err, results) {\n  // handle all errors\n  results.forEach(function (result) {\n    if (result.err) {\n      console.log(result.err);\n    } \n  });\n});\n```\n\n### Nesting\n\nYou can use third argument of an awaiting callback to nest 'gate.await()'.\n\n```js\nvar gate = require('gate');\nvar fs = require('fs');\n\nvar g = gate.create();\nfs.readFile('file1', 'utf8', g.latch({data: 1}));\nfs.readFile('file2', 'utf8', g.latch({data: 1}));\n\ng.await(function (err, results, g) {\n  if (err) throw err;\n  var name1 = results[0].data;\n  var name2 = results[1].data;\n  fs.readFile(name1, 'utf8', g.latch({data: 1}));\n  fs.readFile(name2, 'utf8', g.latch({data: 1}));\n  g.await(function (err, results, g) {\n    if (err) throw err;\n    console.log(results[0].data); // content for name1\n    console.log(results[1].data); // content for name2\n  });\n});\n```",
  "repository": {
    "type": "git",
    "url": "git://github.com/nakamura-to/gate.git"
  },
  "version": "0.3.0"
}
